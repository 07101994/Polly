<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Polly by App-vNext</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Polly</h1>
      <h2 class="project-tagline">Polly is a .NET 3.5 / 4.0 / 4.5 / PCL library that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.</h2>
      <a href="https://github.com/App-vNext/Polly" class="btn">View on GitHub</a>
      <a href="https://github.com/App-vNext/Polly/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/App-vNext/Polly/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="polly" class="anchor" href="#polly" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Polly</h1>

<p>Polly is a .NET 3.5 / 4.0 / 4.5 / PCL (Profile 259) library that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.</p>

<p><a href="https://badge.fury.io/nu/polly"><img src="https://badge.fury.io/nu/polly.svg" alt="NuGet version"></a> <a href="https://ci.appveyor.com/project/joelhulen/polly"><img src="https://ci.appveyor.com/api/projects/status/imt7dymt50346k5u?svg=true" alt="Build status"></a></p>

<p><img src="https://raw.github.com/App-vNext/Polly/master/Polly.png" alt=""></p>

<h1>
<a id="installing-via-nuget" class="anchor" href="#installing-via-nuget" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Installing via NuGet</h1>

<pre><code>Install-Package Polly
</code></pre>

<p>You can install the Strongly Named version via: </p>

<pre><code>Install-Package Polly-Signed
</code></pre>

<h1>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h1>

<h2>
<a id="step-1--specify-the-type-of-exceptions-you-want-the-policy-to-handle" class="anchor" href="#step-1--specify-the-type-of-exceptions-you-want-the-policy-to-handle" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 1 : Specify the type of exceptions you want the policy to handle</h2>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Single exception type</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()

<span class="pl-c">// Single exception type with condition</span>
Policy
  .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == <span class="pl-c1">1205</span>)

<span class="pl-c">// Multiple exception types</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .Or&lt;ArgumentException&gt;()

<span class="pl-c">// Multiple exception types with condition</span>
Policy
  .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == <span class="pl-c1">1205</span>)
  .Or&lt;ArgumentException&gt;(ex =&gt; ex.ParamName == <span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>)</pre></div>

<h2>
<a id="step-2--specify-how-the-policy-should-handle-those-exceptions" class="anchor" href="#step-2--specify-how-the-policy-should-handle-those-exceptions" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 2 : Specify how the policy should handle those exceptions</h2>

<h3>
<a id="retry" class="anchor" href="#retry" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Retry</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Retry once</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .Retry()

<span class="pl-c">// Retry multiple times</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .Retry(<span class="pl-c1">3</span>)

<span class="pl-c">// Retry multiple times, calling an action on each retry </span>
<span class="pl-c">// with the current exception and retry count</span>
Policy
    .Handle&lt;DivideByZeroException&gt;()
    .Retry(<span class="pl-c1">3</span>, (exception, retryCount) =&gt;
    {
        <span class="pl-c">// do something </span>
    });

<span class="pl-c">// Retry multiple times, calling an action on each retry </span>
<span class="pl-c">// with the current exception, retry count and context </span>
<span class="pl-c">// provided to Execute()</span>
Policy
    .Handle&lt;DivideByZeroException&gt;()
    .Retry(<span class="pl-c1">3</span>, (exception, retryCount, context) =&gt;
    {
        <span class="pl-c">// do something </span>
    });</pre></div>

<h3>
<a id="retry-forever" class="anchor" href="#retry-forever" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Retry forever</h3>

<div class="highlight highlight-source-cs"><pre>
<span class="pl-c">// Retry forever</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .RetryForever()

<span class="pl-c">// Retry forever, calling an action on each retry with the </span>
<span class="pl-c">// current exception</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .RetryForever(exception =&gt;
  {
        <span class="pl-c">// do something       </span>
  });

<span class="pl-c">// Retry forever, calling an action on each retry with the</span>
<span class="pl-c">// current exception and context provided to Execute()</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .RetryForever((exception, context) =&gt;
  {
        <span class="pl-c">// do something       </span>
  });</pre></div>

<h3>
<a id="retry-and-wait" class="anchor" href="#retry-and-wait" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Retry and Wait</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Retry, waiting a specified duration between each retry</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetry(<span class="pl-k">new</span>[]
  {
    TimeSpan.FromSeconds(<span class="pl-c1">1</span>),
    TimeSpan.FromSeconds(<span class="pl-c1">2</span>),
    TimeSpan.FromSeconds(<span class="pl-c1">3</span>)
  });

<span class="pl-c">// Retry, waiting a specified duration between each retry, </span>
<span class="pl-c">// calling an action on each retry with the current exception</span>
<span class="pl-c">// and duration</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetry(<span class="pl-k">new</span>[]
  {
    <span class="pl-c1">1.</span>Seconds(),
    <span class="pl-c1">2.</span>Seconds(),
    <span class="pl-c1">3.</span>Seconds()
  }, (exception, timeSpan) =&gt; {
    <span class="pl-c">// do something    </span>
  }); 

<span class="pl-c">// Retry, waiting a specified duration between each retry, </span>
<span class="pl-c">// calling an action on each retry with the current exception, </span>
<span class="pl-c">// duration and context provided to Execute()</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetry(<span class="pl-k">new</span>[]
  {
    <span class="pl-c1">1.</span>Seconds(),
    <span class="pl-c1">2.</span>Seconds(),
    <span class="pl-c1">3.</span>Seconds()
  }, (exception, timeSpan, context) =&gt; {
    <span class="pl-c">// do something    </span>
  });

<span class="pl-c">// Retry a specified number of times, using a function to </span>
<span class="pl-c">// calculate the duration to wait between retries based on </span>
<span class="pl-c">// the current retry attempt (allows for exponential backoff)</span>
<span class="pl-c">// In this case will wait for</span>
<span class="pl-c">//  2 ^ 1 = 2 seconds then</span>
<span class="pl-c">//  2 ^ 2 = 4 seconds then</span>
<span class="pl-c">//  2 ^ 3 = 8 seconds then</span>
<span class="pl-c">//  2 ^ 4 = 16 seconds then</span>
<span class="pl-c">//  2 ^ 5 = 32 seconds</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetry(<span class="pl-c1">5</span>, retryAttempt =&gt; 
    TimeSpan.FromSeconds(Math.Pow(<span class="pl-c1">2</span>, retryAttempt)) 
  );

<span class="pl-c">// Retry a specified number of times, using a function to </span>
<span class="pl-c">// calculate the duration to wait between retries based on </span>
<span class="pl-c">// the current retry attempt, calling an action on each retry </span>
<span class="pl-c">// with the current exception, duration and context provided </span>
<span class="pl-c">// to Execute()</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetry(
    <span class="pl-c1">5</span>, 
    retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="pl-c1">2</span>, retryAttempt)), 
    (exception, timeSpan, context) =&gt; {
      <span class="pl-c">// do something</span>
    }
  );</pre></div>

<h3>
<a id="wait-and-retry-forever" class="anchor" href="#wait-and-retry-forever" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Wait and retry forever</h3>

<div class="highlight highlight-source-cs"><pre>
<span class="pl-c">// Wait and retry forever</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetryForever(retryAttempt =&gt; 
    TimeSpan.FromSeconds(Math.Pow(<span class="pl-c1">2</span>, retryAttempt))
    );

<span class="pl-c">// Wait and retry forever, calling an action on each retry with the </span>
<span class="pl-c">// current exception and the time to wait</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetryForever(
    retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="pl-c1">2</span>, retryAttempt)),    
    (exception, timespan) =&gt;
    {
        <span class="pl-c">// do something       </span>
    });

<span class="pl-c">// Wait and retry forever, calling an action on each retry with the</span>
<span class="pl-c">// current exception, time to wait, and context provided to Execute()</span>
Policy
  .Handle&lt;DivideByZeroException&gt;()
  .WaitAndRetryForever(
    retryAttempt =&gt; TimeSpan.FromSeconds(Math.Pow(<span class="pl-c1">2</span>, retryAttempt)),    
    (exception, timespan, context) =&gt;
    {
        <span class="pl-c">// do something       </span>
    });</pre></div>

<h3>
<a id="circuit-breaker" class="anchor" href="#circuit-breaker" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Circuit Breaker</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Break the circuit after the specified number of exceptions</span>
<span class="pl-c">// and keep circuit broken for the specified duration.</span>
Policy
    .Handle&lt;DivideByZeroException&gt;()
    .CircuitBreaker(<span class="pl-c1">2</span>, TimeSpan.FromMinutes(<span class="pl-c1">1</span>));

<span class="pl-c">// Break the circuit after the specified number of exceptions</span>
<span class="pl-c">// and keep circuit broken for the specified duration,</span>
<span class="pl-c">// calling an action on change of circuit state.</span>
Action&lt;Exception, TimeSpan&gt; onBreak = (exception, timespan) =&gt; { ... };
Action onReset = () =&gt; { ... };
CircuitBreakerPolicy breaker = Policy
    .Handle&lt;DivideByZeroException&gt;()
    .CircuitBreaker(<span class="pl-c1">2</span>, TimeSpan.FromMinutes(<span class="pl-c1">1</span>), onBreak, onReset);

<span class="pl-c">// Break the circuit after the specified number of exceptions</span>
<span class="pl-c">// and keep circuit broken for the specified duration,</span>
<span class="pl-c">// calling an action on change of circuit state,</span>
<span class="pl-c">// passing a context provided to Execute().</span>
Action&lt;Exception, TimeSpan, Context&gt; onBreak = (exception, timespan, context) =&gt; { ... };
Action&lt;Context&gt; onReset = context =&gt; { ... };
CircuitBreakerPolicy breaker = Policy
    .Handle&lt;DivideByZeroException&gt;()
    .CircuitBreaker(<span class="pl-c1">2</span>, TimeSpan.FromMinutes(<span class="pl-c1">1</span>), onBreak, onReset);

<span class="pl-c">// Monitor the circuit state, for example for health reporting.</span>
CircuitState state = breaker.CircuitState;

<span class="pl-c">/*</span>
<span class="pl-c">CircuitState.Closed - Normal operation. Execution of actions allowed.</span>
<span class="pl-c">CircuitState.Open - The automated controller has opened the circuit. Execution of actions blocked.</span>
<span class="pl-c">CircuitState.HalfOpen - Recovering from open state, after the automated break duration has expired. Execution of actions permitted. Success of subsequent action/s controls onward transition to Open or Closed state.</span>
<span class="pl-c">CircuitState.Isolated - Circuit held manually in an open state. Execution of actions blocked.</span>
<span class="pl-c">*/</span>

<span class="pl-c">// Manually open (and hold open) a circuit breaker - for example to manually isolate a downstream service.</span>
breaker.Isolate(); 
<span class="pl-c">// Reset the breaker to closed state, to start accepting actions again.</span>
breaker.Reset(); 

</pre></div>

<h3>
<a id="advanced-circuit-breaker" class="anchor" href="#advanced-circuit-breaker" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Advanced Circuit Breaker</h3>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Break the circuit if, within any period of duration samplingDuration, </span>
<span class="pl-c">// the proportion of actions resulting in a handled exception exceeds failureThreshold, </span>
<span class="pl-c">// provided also that the number of actions through the circuit in the period</span>
<span class="pl-c">// is at least minimumThroughput.</span>

Policy
    .Handle&lt;DivideByZeroException&gt;()
    .AdvancedCircuitBreaker(
        failureThreshold: <span class="pl-c1">0.5</span>, <span class="pl-c">// Break on &gt;=50% actions result in handled exceptions...</span>
        samplingDuration: TimeSpan.FromSeconds(<span class="pl-c1">10</span>), <span class="pl-c">// ... over any 10 second period</span>
        minimumThroughput: <span class="pl-c1">8</span>, <span class="pl-c">// ... provided at least 8 actions in the 10 second period.</span>
        durationOfBreak: TimeSpan.FromSeconds(<span class="pl-c1">30</span>) <span class="pl-c">// Break for 30 seconds.</span>
                );

<span class="pl-c">// Configuration overloads taking stage-change delegates are</span>
<span class="pl-c">// available as described for CircuitBreaker above.</span>

<span class="pl-c">// Circuit state monitoring and manual controls are</span>
<span class="pl-c">// available as described for CircuitBreaker above.</span></pre></div>

<p>For further information on the operation of the Advanced Circuit Breaker, see the <a href="https://github.com/App-vNext/Polly/wiki/Advanced-Circuit-Breaker">Wiki</a></p>

<p>For more information on the Circuit Breaker pattern in general see:</p>

<ul>
<li><a href="http://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html">Making the Netflix API More Resilient</a></li>
<li><a href="http://martinfowler.com/bliki/CircuitBreaker.html">Circuit Breaker (Martin Fowler)</a></li>
<li><a href="https://msdn.microsoft.com/en-us/library/dn589784.aspx">Circuit Breaker Pattern (Microsoft)</a></li>
<li><a href="http://blog.jaywayco.co.uk/circuit-breaking-with-polly/">Circuit breaking with Polly</a></li>
<li><a href="https://web.archive.org/web/20160106203951/http://thatextramile.be/blog/2008/05/the-circuit-breaker">Original Circuit Breaking Link</a></li>
</ul>

<h2>
<a id="step-3--execute-the-policy" class="anchor" href="#step-3--execute-the-policy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Step 3 : Execute the policy</h2>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Execute an action</span>
<span class="pl-k">var</span> policy = Policy
              .Handle&lt;DivideByZeroException&gt;()
              .Retry();

policy.Execute(() =&gt; DoSomething());

<span class="pl-c">// Execute an action passing arbitrary context data</span>
<span class="pl-k">var</span> policy = Policy
    .Handle&lt;DivideByZeroException&gt;()
    .Retry(<span class="pl-c1">3</span>, (exception, retryCount, context) =&gt;
    {
        <span class="pl-k">var</span> methodThatRaisedException = context[<span class="pl-s"><span class="pl-pds">"</span>methodName<span class="pl-pds">"</span></span>];
        Log(exception, methodThatRaisedException);
    });

policy.Execute(
    () =&gt; DoSomething(),
    <span class="pl-k">new</span> Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;() {{ <span class="pl-s"><span class="pl-pds">"</span>methodName<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>some method<span class="pl-pds">"</span></span> }}
);

<span class="pl-c">// Execute a function returning a result</span>
<span class="pl-k">var</span> policy = Policy
              .Handle&lt;DivideByZeroException&gt;()
              .Retry();

<span class="pl-k">var</span> result = policy.Execute(() =&gt; DoSomething());

<span class="pl-c">// Execute a function returning a result passing arbitrary context data</span>
<span class="pl-k">var</span> policy = Policy
    .Handle&lt;DivideByZeroException&gt;()
    .Retry(<span class="pl-c1">3</span>, (exception, retryCount, context) =&gt;
    {
        <span class="pl-k">object</span> methodThatRaisedException = context[<span class="pl-s"><span class="pl-pds">"</span>methodName<span class="pl-pds">"</span></span>];
        Log(exception, methodThatRaisedException)
    });

<span class="pl-k">var</span> result = policy.Execute(
    () =&gt; DoSomething(),
    <span class="pl-k">new</span> Dictionary&lt;<span class="pl-k">string</span>, <span class="pl-k">object</span>&gt;() {{ <span class="pl-s"><span class="pl-pds">"</span>methodName<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>some method<span class="pl-pds">"</span></span> }}
);

<span class="pl-c">// You can of course chain it all together</span>
Policy
  .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == <span class="pl-c1">1205</span>)
  .Or&lt;ArgumentException&gt;(ex =&gt; ex.ParamName == <span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>)
  .Retry()
  .Execute(() =&gt; DoSomething());</pre></div>

<h1>
<a id="post-execution-steps" class="anchor" href="#post-execution-steps" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Post Execution Steps</h1>

<p>Using the <code>ExecuteAndCapture</code> method you can capture the result of executing a policy.</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">var</span> policyResult = Policy
              .Handle&lt;DivideByZeroException&gt;()
              .Retry()
              .ExecuteAndCapture(() =&gt; DoSomething());
<span class="pl-c">/*              </span>
<span class="pl-c">policyResult.Outcome - whether the call succeeded or failed         </span>
<span class="pl-c">policyResult.FinalException - the final exception captured, will be null if the call succeeded</span>
<span class="pl-c">policyResult.ExceptionType - was the final exception an exception the policy was defined to handle (like DivideByZeroException above) or an unhandled one (say Exception). Will be null if the call succeeded.</span>
<span class="pl-c">policyResult.Result - if executing a func, the result if the call succeeded or the type's default value</span>
<span class="pl-c">*/</span></pre></div>

<h1>
<a id="asynchronous-support-net-45-and-pcl-only" class="anchor" href="#asynchronous-support-net-45-and-pcl-only" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Asynchronous Support (.NET 4.5 and PCL Only)</h1>

<p>You can use Polly with asynchronous functions by using the asynchronous methods</p>

<ul>
<li><code>RetryAsync</code></li>
<li><code>RetryForeverAsync</code></li>
<li><code>WaitAndRetryAsync</code></li>
<li><code>CircuitBreakerAsync</code></li>
<li><code>ExecuteAsync</code></li>
<li><code>ExecuteAndCaptureAsync</code></li>
</ul>

<p>In place of their synchronous counterparts</p>

<ul>
<li><code>Retry</code></li>
<li><code>RetryForever</code></li>
<li><code>WaitAndRetry</code></li>
<li><code>CircuitBreaker</code></li>
<li><code>Execute</code></li>
<li><code>ExecuteAndCapture</code></li>
</ul>

<p>For example</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">await</span> Policy
  .Handle&lt;SqlException&gt;(ex =&gt; ex.Number == <span class="pl-c1">1205</span>)
  .Or&lt;ArgumentException&gt;(ex =&gt; ex.ParamName == <span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>)
  .RetryAsync()
  .ExecuteAsync(() =&gt; DoSomethingAsync());
</pre></div>

<h3>
<a id="synchronizationcontext" class="anchor" href="#synchronizationcontext" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>SynchronizationContext</h3>

<p>Async continuations and retries by default do not run on a captured synchronization context. To change this, use <code>.ExecuteAsync(...)</code> overloads taking a boolean <code>continueOnCapturedContext</code> parameter.  </p>

<h3>
<a id="cancellation-support" class="anchor" href="#cancellation-support" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cancellation support</h3>

<p>Async policy execution supports cancellation via <code>.ExecuteAsync(...)</code> overloads taking a <code>CancellationToken</code>.  </p>

<p>Cancellation cancels Policy actions such as further retries and waits between retries.  The delegate taken by the relevant <code>.ExecuteAsync(...)</code> overloads also takes a cancellation token input parameter, to support cancellation during delegate execution.  </p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Try several times to retrieve from a uri, but support cancellation at any time.</span>
CancellationToken cancellationToken = <span class="pl-c">// ...</span>
<span class="pl-k">var</span> policy = Policy
    .Handle&lt;WebException&gt;()
    .Or&lt;HttpRequestException&gt;()
    .WaitAndRetryAsync(<span class="pl-k">new</span>[] { 
        TimeSpan.FromSeconds(<span class="pl-c1">1</span>), 
        TimeSpan.FromSeconds(<span class="pl-c1">2</span>), 
        TimeSpan.FromSeconds(<span class="pl-c1">4</span>) 
    });
<span class="pl-k">var</span> response = <span class="pl-k">await</span> policy.ExecuteAsync(ct =&gt; httpClient.GetAsync(uri, ct), cancellationToken);</pre></div>

<h1>
<a id="3rd-party-libraries" class="anchor" href="#3rd-party-libraries" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3rd Party Libraries</h1>

<ul>
<li>
<a href="https://github.com/dennisdoomen/fluentassertions">Fluent Assertions</a> - A set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style test | <a href="https://github.com/dennisdoomen/fluentassertions/blob/develop/LICENSE">Apache License 2.0 (Apache)</a>
</li>
<li>
<a href="https://github.com/xunit/xunit">xUnit.net</a> - Free, open source, community-focused unit testing tool for the .NET Framework | <a href="https://github.com/xunit/xunit/blob/master/license.txt">Apache License 2.0 (Apache)</a>
</li>
<li><a href="http://www.interact-sw.co.uk/iangblog/2004/04/26/yetmoretimedlocking">Ian Griffith's TimedLock</a></li>
<li><a href="http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29">Steven van Deursen's ReadOnlyDictionary</a></li>
</ul>

<h1>
<a id="acknowledgements" class="anchor" href="#acknowledgements" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Acknowledgements</h1>

<ul>
<li>
<a href="https://github.com/Lokad/lokad-shared-libraries">lokad-shared-libraries</a> - Helper assemblies for .NET 3.5 and Silverlight 2.0 that are being developed as part of the Open Source effort by Lokad.com (discontinued) | <a href="https://raw.github.com/Lokad/lokad-shared-libraries/master/Lokad.Shared.License.txt">New BSD License</a>
</li>
<li>
<a href="https://github.com/michael-wolfenden">@michael-wolfenden</a> - The creator and mastermind of Polly!</li>
<li>
<a href="https://github.com/ghuntley">@ghuntley</a> - Portable Class Library implementation.</li>
<li>
<a href="https://github.com/mauricedb">@mauricedb</a> - Async implementation.</li>
<li>
<a href="https://github.com/RobGibbens">@robgibbens</a> - Added existing async files to PCL project</li>
<li>
<a href="https://github.com/hacko-bede">Hacko</a> - Added extra <code>NotOnCapturedContext</code> call to prevent potential deadlocks when blocking on asynchronous calls</li>
<li>
<a href="https://github.com/ThomasMentzel">@ThomasMentzel</a> - Added ability to capture the results of executing a policy via <code>ExecuteAndCapture</code>
</li>
<li>
<a href="https://github.com/yevhen">@yevhen</a> - Added full control of whether to continue on captured synchronization context or not</li>
<li>
<a href="https://github.com/reisenberger">@reisenberger</a> - Added full async cancellation support</li>
<li>
<a href="https://github.com/reisenberger">@reisenberger</a> - Added async support for ContextualPolicy</li>
<li>
<a href="https://github.com/reisenberger">@reisenberger</a> - Added ContextualPolicy support for circuit-breaker</li>
<li>
<a href="https://github.com/reisenberger">@reisenberger</a> - Extended circuit-breaker for public monitoring and control</li>
</ul>

<h1>
<a id="sample-projects" class="anchor" href="#sample-projects" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sample Projects</h1>

<p><a href="https://github.com/App-vNext/Polly-Samples">Polly-Samples</a> contains practical examples for using various implementations of Polly. Please feel free to contribute to the Polly-Samples repository in order to assist others who are either learning Polly for the first time, or are seeking advanced examples and novel approaches provided by our generous community.</p>

<h1>
<a id="instructions-for-contributing" class="anchor" href="#instructions-for-contributing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Instructions for Contributing</h1>

<p>Please check out our <a href="https://github.com/App-vNext/Polly/wiki/Git-Workflow">Wiki</a> for contributing guidelines. We are following the excellent GitHub Flow process, and would like to make sure you have all of the information needed to be a world-class contributor!</p>

<h1>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>License</h1>

<p>Licensed under the terms of the <a href="http://opensource.org/licenses/BSD-3-Clause">New BSD License</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/App-vNext/Polly">Polly</a> is maintained by <a href="https://github.com/App-vNext">App-vNext</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
