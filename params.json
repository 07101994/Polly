{
  "name": "Polly",
  "tagline": "Polly is a .NET 3.5 / 4.0 / 4.5 / PCL library that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.",
  "body": "Polly\r\n=\r\nPolly is a .NET 3.5 / 4.0 / 4.5 / PCL (Profile 259) library that allows developers to express transient exception handling policies such as Retry, Retry Forever, Wait and Retry or Circuit Breaker in a fluent manner.\r\n\r\n[![NuGet version](https://badge.fury.io/nu/polly.svg)](https://badge.fury.io/nu/polly) [![Build status](https://ci.appveyor.com/api/projects/status/imt7dymt50346k5u?svg=true)](https://ci.appveyor.com/project/joelhulen/polly)\r\n\r\n![](https://raw.github.com/App-vNext/Polly/master/Polly.png)\r\n\r\nInstalling via NuGet\r\n=\r\n\r\n    Install-Package Polly\r\n\r\nYou can install the Strongly Named version via: \r\n\r\n    Install-Package Polly-Signed\r\n\r\nUsage\r\n=\r\n## Step 1 : Specify the type of exceptions you want the policy to handle ##\r\n\r\n```csharp\r\n// Single exception type\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n\r\n// Single exception type with condition\r\nPolicy\r\n  .Handle<SqlException>(ex => ex.Number == 1205)\r\n\r\n// Multiple exception types\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .Or<ArgumentException>()\r\n\r\n// Multiple exception types with condition\r\nPolicy\r\n  .Handle<SqlException>(ex => ex.Number == 1205)\r\n  .Or<ArgumentException>(ex => ex.ParamName == \"example\")\r\n```\r\n\r\n## Step 2 : Specify how the policy should handle those exceptions\r\n\r\n### Retry ###\r\n\r\n```csharp\r\n// Retry once\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .Retry()\r\n\r\n// Retry multiple times\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .Retry(3)\r\n\r\n// Retry multiple times, calling an action on each retry \r\n// with the current exception and retry count\r\nPolicy\r\n    .Handle<DivideByZeroException>()\r\n    .Retry(3, (exception, retryCount) =>\r\n    {\r\n        // do something \r\n    });\r\n\r\n// Retry multiple times, calling an action on each retry \r\n// with the current exception, retry count and context \r\n// provided to Execute()\r\nPolicy\r\n    .Handle<DivideByZeroException>()\r\n    .Retry(3, (exception, retryCount, context) =>\r\n    {\r\n        // do something \r\n    });\r\n```\r\n\r\n### Retry forever ###\r\n\r\n```csharp\r\n\r\n// Retry forever\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .RetryForever()\r\n\r\n// Retry forever, calling an action on each retry with the \r\n// current exception\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .RetryForever(exception =>\r\n  {\r\n        // do something       \r\n  });\r\n\r\n// Retry forever, calling an action on each retry with the\r\n// current exception and context provided to Execute()\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .RetryForever((exception, context) =>\r\n  {\r\n        // do something       \r\n  });\r\n```\r\n\r\n### Retry and Wait ###\r\n\r\n```csharp\r\n// Retry, waiting a specified duration between each retry\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetry(new[]\r\n  {\r\n    TimeSpan.FromSeconds(1),\r\n    TimeSpan.FromSeconds(2),\r\n    TimeSpan.FromSeconds(3)\r\n  });\r\n\r\n// Retry, waiting a specified duration between each retry, \r\n// calling an action on each retry with the current exception\r\n// and duration\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetry(new[]\r\n  {\r\n    1.Seconds(),\r\n    2.Seconds(),\r\n    3.Seconds()\r\n  }, (exception, timeSpan) => {\r\n    // do something    \r\n  }); \r\n\r\n// Retry, waiting a specified duration between each retry, \r\n// calling an action on each retry with the current exception, \r\n// duration and context provided to Execute()\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetry(new[]\r\n  {\r\n    1.Seconds(),\r\n    2.Seconds(),\r\n    3.Seconds()\r\n  }, (exception, timeSpan, context) => {\r\n    // do something    \r\n  });\r\n\r\n// Retry a specified number of times, using a function to \r\n// calculate the duration to wait between retries based on \r\n// the current retry attempt (allows for exponential backoff)\r\n// In this case will wait for\r\n//  2 ^ 1 = 2 seconds then\r\n//  2 ^ 2 = 4 seconds then\r\n//  2 ^ 3 = 8 seconds then\r\n//  2 ^ 4 = 16 seconds then\r\n//  2 ^ 5 = 32 seconds\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetry(5, retryAttempt => \r\n\tTimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) \r\n  );\r\n\r\n// Retry a specified number of times, using a function to \r\n// calculate the duration to wait between retries based on \r\n// the current retry attempt, calling an action on each retry \r\n// with the current exception, duration and context provided \r\n// to Execute()\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetry(\r\n    5, \r\n    retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), \r\n    (exception, timeSpan, context) => {\r\n      // do something\r\n    }\r\n  );\r\n```\r\n\r\n### Wait and retry forever ###\r\n\r\n```csharp\r\n\r\n// Wait and retry forever\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetryForever(retryAttempt => \r\n\tTimeSpan.FromSeconds(Math.Pow(2, retryAttempt))\r\n    );\r\n\r\n// Wait and retry forever, calling an action on each retry with the \r\n// current exception and the time to wait\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetryForever(\r\n    retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),    \r\n    (exception, timespan) =>\r\n    {\r\n        // do something       \r\n    });\r\n\r\n// Wait and retry forever, calling an action on each retry with the\r\n// current exception, time to wait, and context provided to Execute()\r\nPolicy\r\n  .Handle<DivideByZeroException>()\r\n  .WaitAndRetryForever(\r\n    retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),    \r\n    (exception, timespan, context) =>\r\n    {\r\n        // do something       \r\n    });\r\n```\r\n\r\n### Circuit Breaker ###\r\n```csharp\r\n// Break the circuit after the specified number of exceptions\r\n// and keep circuit broken for the specified duration.\r\nPolicy\r\n    .Handle<DivideByZeroException>()\r\n    .CircuitBreaker(2, TimeSpan.FromMinutes(1));\r\n\r\n// Break the circuit after the specified number of exceptions\r\n// and keep circuit broken for the specified duration,\r\n// calling an action on change of circuit state.\r\nAction<Exception, TimeSpan> onBreak = (exception, timespan) => { ... };\r\nAction onReset = () => { ... };\r\nCircuitBreakerPolicy breaker = Policy\r\n    .Handle<DivideByZeroException>()\r\n    .CircuitBreaker(2, TimeSpan.FromMinutes(1), onBreak, onReset);\r\n\r\n// Break the circuit after the specified number of exceptions\r\n// and keep circuit broken for the specified duration,\r\n// calling an action on change of circuit state,\r\n// passing a context provided to Execute().\r\nAction<Exception, TimeSpan, Context> onBreak = (exception, timespan, context) => { ... };\r\nAction<Context> onReset = context => { ... };\r\nCircuitBreakerPolicy breaker = Policy\r\n    .Handle<DivideByZeroException>()\r\n    .CircuitBreaker(2, TimeSpan.FromMinutes(1), onBreak, onReset);\r\n\r\n// Monitor the circuit state, for example for health reporting.\r\nCircuitState state = breaker.CircuitState;\r\n\r\n/*\r\nCircuitState.Closed - Normal operation. Execution of actions allowed.\r\nCircuitState.Open - The automated controller has opened the circuit. Execution of actions blocked.\r\nCircuitState.HalfOpen - Recovering from open state, after the automated break duration has expired. Execution of actions permitted. Success of subsequent action/s controls onward transition to Open or Closed state.\r\nCircuitState.Isolated - Circuit held manually in an open state. Execution of actions blocked.\r\n*/\r\n\r\n// Manually open (and hold open) a circuit breaker - for example to manually isolate a downstream service.\r\nbreaker.Isolate(); \r\n// Reset the breaker to closed state, to start accepting actions again.\r\nbreaker.Reset(); \r\n\r\n\r\n```\r\n\r\n### Advanced Circuit Breaker ###\r\n```csharp\r\n// Break the circuit if, within any period of duration samplingDuration, \r\n// the proportion of actions resulting in a handled exception exceeds failureThreshold, \r\n// provided also that the number of actions through the circuit in the period\r\n// is at least minimumThroughput.\r\n\r\nPolicy\r\n    .Handle<DivideByZeroException>()\r\n    .AdvancedCircuitBreaker(\r\n        failureThreshold: 0.5, // Break on >=50% actions result in handled exceptions...\r\n        samplingDuration: TimeSpan.FromSeconds(10), // ... over any 10 second period\r\n        minimumThroughput: 8, // ... provided at least 8 actions in the 10 second period.\r\n        durationOfBreak: TimeSpan.FromSeconds(30) // Break for 30 seconds.\r\n                );\r\n\r\n// Configuration overloads taking stage-change delegates are\r\n// available as described for CircuitBreaker above.\r\n\r\n// Circuit state monitoring and manual controls are\r\n// available as described for CircuitBreaker above.\r\n```\r\n\r\nFor further information on the operation of the Advanced Circuit Breaker, see the [Wiki](https://github.com/App-vNext/Polly/wiki/Advanced-Circuit-Breaker)\r\n\r\nFor more information on the Circuit Breaker pattern in general see:\r\n* [Making the Netflix API More Resilient](http://techblog.netflix.com/2011/12/making-netflix-api-more-resilient.html)\r\n* [Circuit Breaker (Martin Fowler)](http://martinfowler.com/bliki/CircuitBreaker.html)\r\n* [Circuit Breaker Pattern (Microsoft)](https://msdn.microsoft.com/en-us/library/dn589784.aspx)\r\n* [Circuit breaking with Polly](http://blog.jaywayco.co.uk/circuit-breaking-with-polly/)\r\n* [Original Circuit Breaking Link](https://web.archive.org/web/20160106203951/http://thatextramile.be/blog/2008/05/the-circuit-breaker)\r\n \r\n\r\n## Step 3 : Execute the policy\r\n\r\n```csharp\r\n// Execute an action\r\nvar policy = Policy\r\n              .Handle<DivideByZeroException>()\r\n              .Retry();\r\n\r\npolicy.Execute(() => DoSomething());\r\n\r\n// Execute an action passing arbitrary context data\r\nvar policy = Policy\r\n    .Handle<DivideByZeroException>()\r\n    .Retry(3, (exception, retryCount, context) =>\r\n    {\r\n        var methodThatRaisedException = context[\"methodName\"];\r\n\t\tLog(exception, methodThatRaisedException);\r\n    });\r\n\r\npolicy.Execute(\r\n\t() => DoSomething(),\r\n\tnew Dictionary<string, object>() {{ \"methodName\", \"some method\" }}\r\n);\r\n\r\n// Execute a function returning a result\r\nvar policy = Policy\r\n              .Handle<DivideByZeroException>()\r\n              .Retry();\r\n\r\nvar result = policy.Execute(() => DoSomething());\r\n\r\n// Execute a function returning a result passing arbitrary context data\r\nvar policy = Policy\r\n    .Handle<DivideByZeroException>()\r\n    .Retry(3, (exception, retryCount, context) =>\r\n    {\r\n        object methodThatRaisedException = context[\"methodName\"];\r\n        Log(exception, methodThatRaisedException)\r\n    });\r\n\r\nvar result = policy.Execute(\r\n    () => DoSomething(),\r\n    new Dictionary<string, object>() {{ \"methodName\", \"some method\" }}\r\n);\r\n\r\n// You can of course chain it all together\r\nPolicy\r\n  .Handle<SqlException>(ex => ex.Number == 1205)\r\n  .Or<ArgumentException>(ex => ex.ParamName == \"example\")\r\n  .Retry()\r\n  .Execute(() => DoSomething());\r\n```\r\n\r\nPost Execution Steps\r\n=\r\nUsing the `ExecuteAndCapture` method you can capture the result of executing a policy.\r\n\r\n```csharp\r\nvar policyResult = Policy\r\n              .Handle<DivideByZeroException>()\r\n              .Retry()\r\n              .ExecuteAndCapture(() => DoSomething());\r\n/*              \r\npolicyResult.Outcome - whether the call succeeded or failed         \r\npolicyResult.FinalException - the final exception captured, will be null if the call succeeded\r\npolicyResult.ExceptionType - was the final exception an exception the policy was defined to handle (like DivideByZeroException above) or an unhandled one (say Exception). Will be null if the call succeeded.\r\npolicyResult.Result - if executing a func, the result if the call succeeded or the type's default value\r\n*/\r\n```\r\n\r\nAsynchronous Support (.NET 4.5 and PCL Only)\r\n=\r\nYou can use Polly with asynchronous functions by using the asynchronous methods\r\n\r\n* `RetryAsync`\r\n* `RetryForeverAsync`\r\n* `WaitAndRetryAsync`\r\n* `CircuitBreakerAsync`\r\n* `ExecuteAsync`\r\n* `ExecuteAndCaptureAsync`\r\n\r\nIn place of their synchronous counterparts\r\n\r\n* `Retry`\r\n* `RetryForever`\r\n* `WaitAndRetry`\r\n* `CircuitBreaker`\r\n* `Execute`\r\n* `ExecuteAndCapture`\r\n\r\nFor example\r\n\r\n```csharp\r\nawait Policy\r\n  .Handle<SqlException>(ex => ex.Number == 1205)\r\n  .Or<ArgumentException>(ex => ex.ParamName == \"example\")\r\n  .RetryAsync()\r\n  .ExecuteAsync(() => DoSomethingAsync());\r\n\r\n```\r\n\r\n\r\n### SynchronizationContext ###\r\n\r\nAsync continuations and retries by default do not run on a captured synchronization context. To change this, use `.ExecuteAsync(...)` overloads taking a boolean `continueOnCapturedContext` parameter.  \r\n\r\n### Cancellation support ###\r\n\r\nAsync policy execution supports cancellation via `.ExecuteAsync(...)` overloads taking a `CancellationToken`.  \r\n\r\nCancellation cancels Policy actions such as further retries and waits between retries.  The delegate taken by the relevant `.ExecuteAsync(...)` overloads also takes a cancellation token input parameter, to support cancellation during delegate execution.  \r\n\r\n```csharp\r\n// Try several times to retrieve from a uri, but support cancellation at any time.\r\nCancellationToken cancellationToken = // ...\r\nvar policy = Policy\r\n    .Handle<WebException>()\r\n    .Or<HttpRequestException>()\r\n    .WaitAndRetryAsync(new[] { \r\n        TimeSpan.FromSeconds(1), \r\n        TimeSpan.FromSeconds(2), \r\n        TimeSpan.FromSeconds(4) \r\n    });\r\nvar response = await policy.ExecuteAsync(ct => httpClient.GetAsync(uri, ct), cancellationToken);\r\n```\r\n\r\n\r\n\r\n3rd Party Libraries\r\n=\r\n\r\n* [Fluent Assertions](https://github.com/dennisdoomen/fluentassertions) - A set of .NET extension methods that allow you to more naturally specify the expected outcome of a TDD or BDD-style test | [Apache License 2.0 (Apache)](https://github.com/dennisdoomen/fluentassertions/blob/develop/LICENSE)\r\n* [xUnit.net](https://github.com/xunit/xunit) - Free, open source, community-focused unit testing tool for the .NET Framework | [Apache License 2.0 (Apache)](https://github.com/xunit/xunit/blob/master/license.txt)\r\n* [Ian Griffith's TimedLock] (http://www.interact-sw.co.uk/iangblog/2004/04/26/yetmoretimedlocking)\r\n* [Steven van Deursen's ReadOnlyDictionary] (http://www.cuttingedge.it/blogs/steven/pivot/entry.php?id=29)\r\n\r\nAcknowledgements\r\n=\r\n\r\n* [lokad-shared-libraries](https://github.com/Lokad/lokad-shared-libraries) - Helper assemblies for .NET 3.5 and Silverlight 2.0 that are being developed as part of the Open Source effort by Lokad.com (discontinued) | [New BSD License](https://raw.github.com/Lokad/lokad-shared-libraries/master/Lokad.Shared.License.txt)\r\n* [@michael-wolfenden](https://github.com/michael-wolfenden) - The creator and mastermind of Polly!\r\n* [@ghuntley](https://github.com/ghuntley) - Portable Class Library implementation.\r\n* [@mauricedb](https://github.com/mauricedb) - Async implementation.\r\n* [@robgibbens](https://github.com/RobGibbens) - Added existing async files to PCL project\r\n* [Hacko](https://github.com/hacko-bede) - Added extra `NotOnCapturedContext` call to prevent potential deadlocks when blocking on asynchronous calls\r\n* [@ThomasMentzel](https://github.com/ThomasMentzel) - Added ability to capture the results of executing a policy via `ExecuteAndCapture`\r\n* [@yevhen](https://github.com/yevhen) - Added full control of whether to continue on captured synchronization context or not\r\n* [@reisenberger](https://github.com/reisenberger) - Added full async cancellation support\r\n* [@reisenberger](https://github.com/reisenberger) - Added async support for ContextualPolicy\r\n* [@reisenberger](https://github.com/reisenberger) - Added ContextualPolicy support for circuit-breaker\r\n* [@reisenberger](https://github.com/reisenberger) - Extended circuit-breaker for public monitoring and control\r\n\r\nSample Projects\r\n=\r\n[Polly-Samples](https://github.com/App-vNext/Polly-Samples) contains practical examples for using various implementations of Polly. Please feel free to contribute to the Polly-Samples repository in order to assist others who are either learning Polly for the first time, or are seeking advanced examples and novel approaches provided by our generous community.\r\n\r\nInstructions for Contributing\r\n=\r\nPlease check out our [Wiki](https://github.com/App-vNext/Polly/wiki/Git-Workflow) for contributing guidelines. We are following the excellent GitHub Flow process, and would like to make sure you have all of the information needed to be a world-class contributor!\r\n\r\nLicense\r\n=\r\nLicensed under the terms of the [New BSD License](http://opensource.org/licenses/BSD-3-Clause)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}